record(motor,"$(P)$(M)")
{
	field(DESC,"$(DESC)")
	field(DTYP,"$(DTYP)")
	field(DIR,"$(DIR)")
	field(VELO,"$(VELO)")
	field(VBAS,"$(VBAS)")
	field(ACCL,"$(ACCL)")
	field(ACCU,"$(ACCU=0)")
	field(BDST,"$(BDST)")
	field(BVEL,"$(BVEL)")
	field(BACC,"$(BACC)")
	field(OUT,"@asyn($(PORT),$(ADDR))")
	field(MRES,"$(MRES)")
	field(PREC,"$(PREC)")
	field(EGU,"$(EGU)")
	field(DHLM,"$(DHLM)")
	field(DLLM,"$(DLLM)")
	field(INIT,"$(INIT)")
	field(RTRY,"$(RTRY=10)")
    field(RSTM,"$(RSTM=Never)")
	field(TWV,"1")
	# ISIS local archiving and alarm
	info(archive, "0.02 VAL RBV DVAL OFF MSTA DIR CNEN MOVN DMOV MISS RCNT")
	info(alarm, "Motors")
}

# These records make the motor resolution, offset and direction available to the driver
# which is needed for profile moves and other applications

# Motor direction for this axis
record(longout,"$(P)$(M)Direction") {
    field(DESC, "$(M) direction")
    field(DOL,  "$(P)$(M).DIR CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_REC_DIRECTION")
}


# Motor offset for this axis
record(ao,"$(P)$(M)Offset") {
    field(DESC, "$(M) offset")
    field(DOL,  "$(P)$(M).OFF CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_REC_OFFSET")
    field(PREC, "$(PREC)")
}


# Motor resolution for this axis
record(ao,"$(P)$(M)Resolution") {
    field(DESC, "$(M) resolution")
    field(DOL,  "$(P)$(M).MRES CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_REC_RESOLUTION")
    field(PREC, "$(PREC)")
}

# ISIS local aliases for genie_python
alias("$(P)$(M)", "$(P)$(M):SP")
alias("$(P)$(M)", "$(P)$(M):SP:RBV")

# ISIS enable/disable
record(bo, "$(P)$(M)_able") {
  field(DESC, "motor enable")
  field(PINI, "YES")
  field(OUT, "$(P)$(M).DISP")
  field(ZNAM, "Enable")
  field(ONAM, "Disable")
  field(UDFS, "NO_ALARM")
}

record(ao,"$(P)$(M)_MRESMON")
{
    field(OMSL, "closed_loop")
    field(DOL, "$(P)$(M).MRES CP")
    field(DTYP, "asynFloat64")
    field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_RESOLUTION")
}

record(calcout,"$(P)$(M)_MERATMON")
{
    field(INPA, "$(P)$(M).MRES CP")
    field(INPB, "$(P)$(M).ERES CP")
	field(CALC, "(A != 0 && B != 0) ? A / B : 0")
	field(OOPT, "When Non-zero")
    field(OUT, "$(P)$(M)_MERAT PP")
}

record(ao,"$(P)$(M)_MERAT")
{
    field(DTYP, "asynFloat64")
    field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_ENCODER_RATIO")
}

# allow splitting out of MSTA
record(mbbiDirect, "$(P)$(M):_MSTABITS")
{
    field(INP, "$(P)$(M).MSTA CP")
}

record(bi, "$(P)$(M)_HOMED")
{
    field(DESC, "Motor Homed")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(INP, "$(P)$(M):_MSTABITS.BE CP")
}
